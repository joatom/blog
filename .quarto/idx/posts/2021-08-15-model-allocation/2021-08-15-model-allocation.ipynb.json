{"title":"Model allocation","markdown":{"yaml":{"title":"Model allocation","description":"Applying portfolio theory on model ensembling.","image":"model_allocation.png","categories":["Basics","ML","Economics"],"date":"2021-08-15","toc":true,"comments":{"utterances":{"repo":"joatom/blog"}},"badges":true,"author":"Johannes Tomasoni","from":"markdown+emoji","keep-ipynb":true},"headingText":"1. Why ensembling works","containsRefs":false,"markdown":"\n\n> This notebook was originally published on https://www.kaggle.com/joatom/model-allocation.\n\n\nIn this notebook I experiment with two ensembling strategies.\n\nThere are many ways to combine different models to improve predictions. A common technique for regression tasks is taking a weighted average of the model predictions (`y_pred = (m1(x)*w1 + ... + mn(x)*wn) / n`). Another common technique is building a meta model, that is trained on the models' outputs.\n\nThe first chapter starts with a simple linear combination of two models. And we explore with an simple example, why ensembling actually works. These insights will lead, in the second chapter, to the first technique on how to choose weights for a linear ensemble by using residual variance. In the third chapter an alternative for the weight selection is examined. This second technique is inspired by portfolio theory (a theory to combine financial assets). In the fourth chapter the two techniques are applied and compared on the  [Tabular Playground Series (TPS) - Aug 2021](https://www.kaggle.com/c/tabular-playground-series-aug-2021) competition. Finaly cross validation (CV) and leaderboard (LB) Scores are listed in the fith chapter.\n\n:::{.callout-note}\nFor the ease of explanation we make some simplifying assumptions, such as equal distribution of the data, same distribution on unseen data, ... (just think of a vanilla world).\n:::\n\n\nSuppose there are two fitted regression models and they predict values like shown in the first chart.\n\nTo get a better intuition on how good the two models fit the ground truth, we plot the residuals `y_true(x)-m(x)`.\n\nIf we had to choose one of the models, which one would we prefer? \nModel 2 does better on the first data point and perfect on the third, but it contains an outlier the 5th data point.\n\nLet's look at the mean and the variance of the residuals.\n\nOn the long run Model2 has an average residual of 0. Model 1 carries along a residual of 0.0714. So on average Model 2 seams to do better. \n\nBut Model 2 also has a higher variance. That implies we have a great chance to do a great prediction (e.g. x=3) but we also have high risk to screw the prediction (e.g. x=5). \n\n\nNow we build a simple linear ensemble of the two models like `ens = 0.5 * m1 + 0.5 m2`.\n\nThe ensemble line is closer to the true values. It also looks smoother then m1 and m2.\n\nIn the residual chart we can see that the ensemble does a bit worse for x=3 compared to Model 2. But it also decreases the residuals for the outliers (points 1, 5, 7).\n\nLet's check the stats:\n\nWe dramatically reduced the variance, hence reduced the risk/chance. The mean value is now in between Model 1 and Model 2.\n\nFinally let's play around with the model weights in the ensemble and check how mean and variance change. \n\nWith the previous 50:50 split the variance seems almost at the lowest point. So we only get a reduction of the mean below 0.0357 if we allow the ensemble to have more variance, hence take more risk.\n\n# 2. Weights by residual variance\n\nSince the Model 1 and Model 2 are well fitted, their average residuals are pretty close to 0. So let's focus on reducing our variance to avoid surprises on later later predictions.\n\nWe now solve for the optimal weights that minimizes the variance of the residual of our ensemble with this function:\n\nWe also define a constraint so that the `w.sum() == 0`:\n\nIf you want, you can also set bounds, so that the weights want be negative.\n\nI don't. I like the idea of going *short* with a model. And negative weights really increase the results of TPS predictions in chapter 4. \n\nNow, we are all set to retrieve the optimal weights. \n\nLet's see how the calculated weights perform.\n\nWe con compare the results with the first ensemble 50:50 split. \nWith the calculated weights we could further reduce the variance of the model (0.2219 -> 0.2157). But unfortunately the mean increased a bit (0.0357 -> 0.0380).\n\nWe see the trade off between mean and variance and have to decide if we prefer a more stable model or take some risk for better results.\n\n# 3. Portfolio theory for ensembling\n\nIn finance different assets are often combined in a portfolio. There are many criteria for the asset selection/allocation. One of them is by choosing a risk strategy. In 1952 the economist Harry Markowitz defined a *Portfolio Selection* strategy which built the foundation of many portfolio strategies to come. There is a great summary on [Wikipidia](https://en.wikipedia.org/wiki/Modern_portfolio_theory), but the original paper can also be found with a google search.\n\n\nSo, what it is all about. Let's assume we are living in an easy, plain vanilla world. We want to build a portfolio that yields high return with low risk. That's not easy. If we only buy stocks of our favorite fruit grower, a rainy summer would result in a low return. Wouldn't it be smart to also buy stocks of a raincoat producer, just in case. But what if the summer was sunny, then we would have rather invested the entire money in fruits instead of raincoats. It's clearly a trade off. Either we lower the risk of loosing money in a rainy summer and invest in both (fruits and raincoats). Or we take the risk investing all money in fruits to maybe gain more money. And if we lower the risk, in which raincoat producer should we invest? The one with the bumpy stock price or the one with a steady, but slowly growing stock price.\n\nNow, we already see the first similarities between our ensemble example above and the Portfolio Theory. Risk can be measured through variance and a good return of our ensemble is results in a low expected residual.\n\nBut there is even more in Portfolio Theory. It also takes dependencies between assets into account. If the summer is sunny the fruit price goes up and the raincoat price goes down, they are somewhat negative correlated. \n\nSince we expect the average residual of our fitted models to be close to 0 and we build a linear model, we can expect our ensemble average residual also to be close to 0. Therefore, we focus on optimizing the portfolio variance, which can be boiled down to `Var_p = w'*Cov*w`. The covariance measures the dependency between combined models and also considers the variance.\n\n> What data can we actually use? In the financial example *returns* are the increase or decrease of an asset price (p/p_t-1), hence we are looking on returns for a certain period of time. In ML we can take our **out-of-fold** (oof) predictions and calculate the residuals from the train targets to build a dataset.\n\n> Can we do this despite we are looking at a time-series in the financial example? Yes, in this *basic* portfolio theory we don't take time dependencies into account. But it's important to keep the same order for the different asset returns for correlation/covariance calculation. We want to compare the residual of model 1 and 2 for always the same data item.\n\nThe optimization function for the second ensemble technique is:\n\nRun the optimization.\n\nThe weights are the same as in the first technique. That really surprised me. And I run a couple of examples with different models. But the weights were only slightly different between the two techniques.\n\n# 4. Ensembling TPS Aug 2021\n\nNow that we have to techniques to ensemble, let's try them on the [TPS August 2021](https://www.kaggle.com/c/tabular-playground-series-aug-2021/overview) data.\n\nWe do a 7 kfold split and calculate the residuals on the out-of-fold-predictions, that are used for validation. We train 7 regression models with different architecture so we get some diversity.\n\nFit models and save oof predictions.\n\nLet's a look at the correlation heatmap.\n\nXGB and KNN are most diverse, so I export a 50:50 ensemble. I'll also export an equally weighted ensemble of all models and HGB only because it is the best single model.\n\nNext we inspect the variance and mean of the residuals. Means are close to 0, as expected.\n\nThese are the histograms of the residuals:\n\nFinally, we apply the two techniques to calculate the ensembling weights\n\n# 5. Results\n\nThe competition metric is root mean squared error (RMSE). These are the scores of the different ensembles:\n\n|Ensemble|     CV|public LB|\n|--------|-------|---------|\n|HGB only|7.86563|7.90117|\n|All weights eq.|7.88061|7.92183|\n|XGB and KNN (50:50)| 7.89321|7.91603|\n|Ex1 (Var)| 7.85594|7.88876|\n|Ex2 (Cov)| 7.85594|7.88876|\n\n# References\n\n- Modern Portfolio Theory: https://en.wikipedia.org/wiki/Modern_portfolio_theory\n- TPS August 2021 Competition: https://www.kaggle.com/c/tabular-playground-series-aug-2021/overview\n\n# Ressources\n- Original notebook: https://www.kaggle.com/joatom/model-allocation\n- TPS data: https://www.kaggle.com/c/tabular-playground-series-aug-2021/data\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":true,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"from":"markdown+emoji","output-file":"2021-08-15-model-allocation.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.256","bibliography":["../../references.bib"],"theme":{"light":"flatly","dark":"darkly"},"title-block-banner":true,"sidebar":false,"title":"Model allocation","description":"Applying portfolio theory on model ensembling.","image":"model_allocation.png","categories":["Basics","ML","Economics"],"date":"2021-08-15","comments":{"utterances":{"repo":"joatom/blog"}},"badges":true,"author":"Johannes Tomasoni"},"extensions":{"book":{"multiFile":true}}}}}